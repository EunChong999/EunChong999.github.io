---
layout: single
title: Chapter 11 비트 연산자와 시프트 연산자로 비트 단위 연산하기
categories:
  - Language
tags:
  - C#
  - Study
---
>이 포스트는 비트 연산자와 시프트 연산자로 비트 단위 연산하기에 대한 내용입니다.

>비트 연산자(&, \|, ^, \~)와 시프트 연산자(<<, >>)는 이진수 비트 단위로 연산을 수행한다.

# 1 비트 연산자

>비트 연산자(bit operator)는 정수형 데이터의 값을 이진수 비트 단위로 연산을 수행할 때 사용한다. 비트 연산자의 종류는 다음 표와 같다.

- 비트 연산자

| 연산자 | 의미                         | 설명                           |
| --- | -------------------------- | ---------------------------- |
| &   | 논리곱(AND)                   | 비트 값이 둘 다 1일 때만 1, 그렇지 않으면 0 |
| \|  | 논리합(OR)                    | 비트 값이 하나라도 1이면 1, 그렇지 않으면 0  |
| ^   | 배타적 논리합(XOR, Exclusive OR) | 비트 값이 서로 다를 때만 1, 그렇지 않으면 0  |
| ~   | NOT                        | 비트 값이 1이면 0, 0이면 1           |

## 1.1 비트 AND 연산자(&) 사용하기

```cs
> byte x = 0b1010; // 10
> byte y = 0b1100; // 12
> Console.WriteLine($"  {Convert.ToString(x, 2)} -> {x}"); // x를 이진수 -> 십진수
  1010 -> 10
> Console.WriteLine($"& {Convert.ToString(y, 2)} -> {y}"); // y를 이진수 -> 십진수
& 1100 -> 12
> 
> // x AND y를 이진수로 표현 -> 십진수로 2칸 잡고 표현
> Console.WriteLine($"  {Convert.ToString(x & y, 2)} -> {x & y,2}");
  1000 ->  8
```

>비트 AND 연산자인 & 연산자처럼 항을 2개 갖는 2항 연산자는 앞뒤로 공백을 두면 가독성이 좋다. x%y 보다는 x % y 형태를 추천한다.

## 1.2 비트 OR 연산자(|) 사용하기

>| 연산자는 키보드의 파이프 기호(버티컬 바)를 사용한다. 

```cs
> using static System.Console; // System.Console 줄여서 사용
> 
> byte x = 0b1010;
> byte y = 0b1100;
> WriteLine($"  {Convert.ToString(x, 2)} -> {x}");
  1010 -> 10
> WriteLine($"| {Convert.ToString(y, 2)} -> {y}");
| 1100 -> 12
> 
> // x OR y를 이진수 -> 십진수
> WriteLine($"  {Convert.ToString(x | y, 2)} -> {x | y, 2}");
  1110 -> 14
```

## 1.3 비트 XOR 연산자(^) 사용하기

>비트 XOR 연산자인 ^ 연산자는 두 비트의 값이 서로 다를 때 1이다. 1 ^ 0과 0 ^ 1일 때만 1이고 나머지는 0이다. 

```cs
> using static System.Console;
> 
> byte x = 0b_1010;
> byte y = 0b_1100;
> WriteLine($"  {Convert.ToString(x, 2)} -> {x}");
  1010 -> 10
> WriteLine($"^ {Convert.ToString(y, 2)} -> {y}");
^ 1100 -> 12
> 
> // x XOR y를 이진수로 표현 -> 십진수로 표현
> WriteLine($"  {Convert.ToString(x ^ y, 2).PadLeft(4, '0')} -> {x ^ y, 2}");
  0110 ->  6
```

## 1.4 비트 NOT 연산자(~) 사용하기

>비트 NOT 연산자인 ~ 연산자는 물결(틸드) 기호를 사용한다. ~ 연산자는 비트 값이 1이면 0으로, 0이면 1로 바꾼다. 이렇게 비트가 바뀌는 것을 '비트 반전'이라고 한다.

```cs
> using static System.Console;
> 
> byte x = 0b_0000_1010; // 10
> 
> // x를 8자리 이진수로 표현 -> 십진수로 3자리 잡고 표현
> WriteLine($"~ {Convert.ToString(x, 2).PadLeft(8, '0')} -> {x, 3}");
~ 00001010 ->  10
> // NOT x를 8자리 이진수로 표현 -> 십진수로 3자리 잡고 표현 
> WriteLine($"  {Convert.ToString((byte)~x, 2).PadLeft(8, '0')} -> {~x, 3}");
  11110101 -> -11
```

>음수를 이진수로 표현하는 것은 2의 보수법을 활용한다. C#은 알아서 이진수 값을 양수 또는 정수로 출력해준다. 

- Note
	- 1의 보수
		- 1의 보수는 이진수의 모든 비트를 뒤집는 것이다. 즉, 0은 1로, 1은 0으로 바꾼다. 예를 들어, 4비트 이진수 `1010`의 1의 보수는 `0101`이다.
	- 2의 보수
		- 2의 보수는 1의 보수에 1을 더한 것이다. 예를 들어, `1010`의 1의 보수가 `0101`이므로, 여기에 1을 더하면 `0110`이 되어 `1010`의 2의 보수가 된다.

## 1.5 비트 연산자 네 가지 모두 사용하기

- BitwiseOperator.cs

```cs
using System;

class BitwiseOperator
{
    static void Main()
    {
        var x = Convert.ToInt32("1010", 2);
        var y = Convert.ToInt32("0110", 2);

        var and = x & y;
        Console.WriteLine($"  {and} : {Convert.ToString(and, 2)}");

        var or = x | y;
        Console.WriteLine($" {or} : {Convert.ToString(or, 2)}");

        var xor = x ^ y;
        Console.WriteLine($" {xor} : {Convert.ToString(xor, 2)}");

        var not = ~x; // 2의 보수법에 따라서 1010 + 1 그리고 부호를 -로 -1011 => -11
        Console.WriteLine($"{not} : {Convert.ToString(not, 2)}");
    }
}
```

- 실행 결과

```cs
  2 : 10
 14 : 1110
 12 : 1100
-11 : 11111111111111111111111111110101
```

>이진수 1010과 0110에서 &, |, ^ 연산자를 사용한 결과와 1010에 ~ 연산자를 붙여 비트를 반전시키는 연산의 사용 결과가 나온다. 

# 2 시프트 연산자

>시프트 연산자(shift operator)는 정수 데이터가 담겨 있는 메모리의 비트를 왼쪽(<<) 또는 오른쪽(>>)으로 지정한 비트만큼 이동시킨다. 

>시프트 연산자를 사용하면 비트의 자리를 이동할 수 있다. 예를 들어 정수형 데이터인 2를 이진수로 표현하면 0010이다. 왼쪽(<<) 시프트 연산자를 사용하여 한 칸 이동하면 0100이 된다. 오른쪽 (>>) 시프트 연산자를 사용하여 한 칸 이동하면 0001이 된다.

>시프트 연산자의 종류는 다음과 같다.

- 시프트 연산자
![[제목 없는 다이어그램.drawio (1) 2.png]]

| 연산자 | 의미      | 예          | 설명                                                                                 |
| --- | ------- | ---------- | ---------------------------------------------------------------------------------- |
| >>  | 왼쪽 시프트  | 변수 << 비트 값 | 비트 값만큼 왼쪽으로 비트 이동<br><br>결괏값이 변수 값 * 2의 비트 값 승 == 비트당 2배<br><br>변수 값 곱하기 2의 거듭제곱   |
| <<  | 오른쪽 시프트 | 변수 >> 비트 값 | 비트 값만큼 오른쪽으로 비트 이동<br><br>결괏값이 변수 값 / 2의 비트 값 승 === 비트당 2배<br><br>변수 값 나누기 2의 거듭제곱 |

>시프트 연산자 내용을 그림으로 표현하면 다음과 같다. 

![](https://i.imgur.com/qJ7cWQX.png)

>정수 2의 이진수인 0010을 왼쪽으로 2칸 이동하면 1000이 되어 정수 8이 된다. 정수 32의 이진수인 0101000을 오른쪽으로 2칸 이동하면 0001010이 되어 정수 10이 된다.

```cs
> int number = 2; // 0010
> 
> Console.WriteLine(number << 1); // 0010 -> 0100
4
> 
> Console.WriteLine(number >> 1); // 0010 -> 0001
1
```

>0010을 왼쪽으로 비트 한 칸을 이동하면 0100이 되고, 0010을 오른쪽으로 비트 한 칸을 이동하면 0001이 된다. 시프트 연산자는 내부적으로는 이진수로 계산되지만 정수형 데이터이기에 출력할 때는 그대로 십진수로 표현된다.

## 2.1 비트 연산자와 시프트 연산자를 대입 연산자와 함께 사용하기

>비트 연산자와 시프트 연산자도 대입 연산자와 함께 사용할 수 있다. 사용 방법은 일반적인 대입 연산자와 동일하다.

- A &= B;
- A  \|= B;
- A ^= B;
- A <<= B;
- A >>= B;

```cs
> byte num1 = 4; // 4 : 0000_0100
> num1 &= 5;     // 5(0101) & 4(0100) => 4(0000_0100)
> Console.WriteLine(num1);
4
> 
> byte num2 = 4; // 4 : 0000_0100
> num2 |= 1;     // 1(0001) | 4(0100) => 5(0000_0101)
> Console.WriteLine(num2);
5
> 
> byte num3 = 4; // 4 : 0000_0100
> num3 ^= 2;     // 2(0010) ^ 4(0100) => 6(0000_0110)
> Console.WriteLine(num3);
6
> 
> byte num4 = 4; // 4 : 0000_0100
> num4 <<= 1;    // 4(0100) << 1 => 8(0000_1000)
> Console.WriteLine(num4);
8
> 
> byte num5 = 4; // 4 : 0000_0100
> num5 >>= 1;    // 4(0100) >> 1 => 2(0000_0010)
> Console.WriteLine(num5);
2
```

>이진수 비트 연산 후 그 결괏값을 다시 변수에 할당한 내용이 출력된다.

>비트 연산자와 시프트 연산자는 C 언어 같은 프로그래밍 언어로 성능이 낮은 장치에서 프로그래밍을 할 때 많이 사용한다. 다만 C#에서 응용 프로그램을 제작할 때는 자주 사용하지 않는다. 

# 3 기타 연산자

## 3.1 조건 연산자

>조건 연산자(conditional operator)는 조건에 따라서 참일 때와 거짓일 때 결과를 다르게 변환하며, ? : 형태의 연산자이다. 조건 연산자는 항이 3개여서 3항 연산자(ternary operator)라고도 한다. 
>3항 연산자는 if~else 문의 축약형이기도 하다.

```cs
> (5 > 3) ? "TRUE" : "FALSE"
"TRUE"
```

>3항 연산자인 ? : 연산자는 항이 3개 있는 연산자로 다음과 같이 조건을 처리한다. 조건식이 참이면 식1이 실행되고, 조건식이 거짓이면 식2가 실행된다.

```cs
조건식 ? 식1 : 식2;
```

>3항 연산자의 결괏값이 특정 값을 반환하기에 다음과 같이 표현하기도 한다.

```cs
조건식 ? 값1 : 값2;
```

- ConditionalOperator.cs

```cs
using System;

class ConditionalOperator
{
    static void Main()
    {
        int number = 3;

        // number가 짝수이면 result 변수에 "짝수"를 담고, 그렇지 않으면 "홀수" 담기
        string result = (number % 2 == 0) ? "짝수" : "홀수";

        Console.WriteLine($"{number}은(는) {result}입니다.");
    }
}
```

- 실행 결과

```cs
3은(는) 홀수입니다.
```

>number 변수에 3을 넣은 후 (number % 2 == 0)을 물어보면 거짓(false)이 된다. ? 기호 앞의 식이 false이기에 '홀수'가 result 변수에 담긴다. 즉, 조건식이 참이면 '짝수'를 반환하고 그렇지 않으면 '홀수'를 반환한다. 조건 연산자(3항 연산자)는 제어문의 if 문으로 대체할 수 있다. 

## 3.2 조건 연산자를 사용하여 최댓값 정하기

>다음 코드는 들어오는 값이 20 이상이면 20으로 초기화하고, 20 미만이면 해당 값으로 초기화한다.

```cs
> const int max_size = 20;
> int pageSize = 0;
> pageSize = 10;
> pageSize = (pageSize > max_size) ? max_size : pageSize;
> pageSize
10
> pageSize = 50;
> pageSize = (pageSize > max_size) ? max_size : pageSize;
> pageSize
20
```

## 3.3 조건 연산자를 사용하여 문자 비교하기

```cs
> string result = "";
> 
> // 'A'는 'B'보다 작으므로 참 -> 앞의 문자열을 result 변수에 저장
> result = ('A' < 'B') ? "'A'는 'B' 보다 작습니다." : "A B C 순서대로 커집니다.";
> result
"'A'는 'B' 보다 작습니다."
> 
> // 'Z'는 'a'보다 작으므로 참 -> 앞의 문자열을 result 변수에 저장
> result = ('Z' < 'a') ? "'Z'는 'a' 보다 작습니다." : "대문자보다 소문자가 더 큽니다.";
> result
"'Z'는 'a' 보다 작습니다."
```

>프로그래밍 언어에서는 A, B, C, ..., Z, a, b, c, ..., z 순서로 크기가 정해져 있다. 

## 3.4 조건(3항) 연산자로 절댓값 구하기

>조건 연산자인 3항 연산자를 사용하면 다음 코드처럼 정수의 절댓값을 편하게 구할 수 있다.

```cs
> var num = -21;
> var abs = (num < 0) ? -num : num; // 3항 연산자로 음수만 부호 변환
> Console.WriteLine($"{num}의 절댓값 : {abs}");
-21의 절댓값 : 21
```

## 3.5 나열(콤마) 연산자

>콤마를 구분자로 하여 한 문장에 변수 여러 개를 선언할 때 사용한다. 이러한 콤마 연산자(comma operator)를 나열 연산자라고도 한다.

>나열 연산자는 다음과 같이 사용한다.

```cs
> int a = 10, b = 20, c = 30;
```

>이처럼 콤마로 할당문 3개를 지정하면 a, b, c 변수 모두 int 형 변수로 선언된다.

## 3.6 sizeof 연산자

>sizeof 연산자는 단항 연산자로 데이터 형식 자체의 크기를 구하는 데 사용한다. sizeof(int) 형태로 사용하며, int의 데이터 형식 크기인 4가 값으로 나온다. 운영 체제와 컴퓨터마다 결괏값이 다르게 나올 수 있다. 

```cs
> Console.WriteLine("sizeof(데이터 형식)");
sizeof(데이터 형식)
> Console.WriteLine($"  char 형식 : {sizeof(  char)} byte");
  char 형식 : 2 byte
> Console.WriteLine($"   int 형식 : {sizeof(   int)} byte");
   int 형식 : 4 byte
> Console.WriteLine($"  long 형식 : {sizeof(  long)} byte");
  long 형식 : 8 byte
> Console.WriteLine($" float 형식 : {sizeof( float)} byte");
 float 형식 : 4 byte
> Console.WriteLine($"double 형식 : {sizeof(double)} byte");
double 형식 : 8 byte
```

>sizeof 연산자는 다른 연산자와 달리 sizeof() 형태로 괄호로 묶어 준다. 예를 들어 C#에서 기본으로제공하는 double 같은 형식은 sizeof(double) 형태로 구할 수 있다.

# 4 연산자 우선순위

>연산자 여러 개를 함께 사용할 때는 연산자 우선순위(precedence)에 따라 계산된다. 예를 들어 산술 연산자에서는 + 보다 * 우선순위가 더 높다. () 연산자를 사용하면 우선순위를 변경할 수 있다.

- 우선순위가 적용된 산술 연산 구문

|                                                                                                                    |                                                                                                                        |
| ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------- |
| int A; int B; int C; int D;<br>A = 2; B = 3; C = 4;<br>D = A + B * C;<br>Console.WriteLine( D );<br>2 + 3 * 4 = 14 | int A; int B; int C; int D;<br>A = 2; B = 3; C = 4;<br>D = (A + B) * C;<br>Console.WriteLine( D );<br>(2 + 3) * 4 = 20 |

>다음은 C#에서 사용하는 주요 연산자의 우선순위이다.

- 연산자 우선순위

| 항목     | 연산자                           |     우선순위     |
| ------ | ----------------------------- | :----------: |
| 괄호 연산자 | ()                            |   높음<br>▲    |
| 증감 연산자 | ++, - -                       |              |
| 산술 연산자 | -(음수)<br>\*, /<br>%<br>+, -   | <br><br><br> |
| 연결 연산자 | +                             |              |
| 관계 연산자 | \==, !=, <, >, <=, >=         |              |
| 논리 연산자 | !(Not)<br>&&(And)<br>\|\|(Or) | <br>▼<br>낮음  |

```cs
> 3 + 4 * 2
11
> (3 + 4) * 2
14
> 10 / 5 * 2 + 1
5
> 15 / (5 * (2 + 1))
1
```
